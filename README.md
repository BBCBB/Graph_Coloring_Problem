# Graph_Coloring_Problem
This code is under review and improvement to tackle challenging problems in terms of size and diversity.
In order to solve this problem efficiently in terms of the solving time and the quality of the solution (how you can color the graph with the minimum number of colors), you need to know about constraint programming and symmetry breaking approaches. However, there is not a uniform and predefined strategy to do so. First Fail Principle can be helpful in many areas, which states that “To succeed, try first where you are most likely to fail.” In other words, you need to prioritize the nodes that have the most degrees.
I have tried two strategies so far. In the first one, I let the algorithm choose the nodes based on their degrees, and in the second one, I tried the saturation degree of the nodes firstly, and if it was the same for multiple nodes, I chose the node with the largest degree. Surprisingly, the first one performs better than the latter (Coloring_Sat in the repository). In the next step, I will try other approaches like letting in different permutations when the chromatic number of the graph exceeds an upper bound.

Update: I tried another strategy with two phases to deal with the problem. In this strategy, an upper bound to the chromatic number is defined by the user. In the first layer, you should address the problem using the second strategy stated above and choose nodes to assign a color based on their saturation degree. Nevertheless, whenever the assigned color exceeds the defined upper bound, you must backtrack. In other words, in this situation, the algorithm tends to avoid violating the upper bound constraint by trying other schemes and permutations for the neighbor nodes to the node that its color had exceeded the bound. I used this algorithm to solve problems with different sizes and found it useful and efficient in graphs with less than 1000 nodes, 250000 edges, and 550 as the largest degree for a node. In this problem, I let the program 1 hour, but it was not able to come up with a solution. As a result, there is a trade-off between solving time and optimality here, and I recommend choosing new nodes only based on their degree (not saturation degree) in large-scale problems.

In fact, using an upper bound is kind of a combination of constraint programming and local search. When the solution exceeds the allowed chromatic number, we will choose the variable that has caused the violation, and adopting a greedy flavor, alter its priority to get colored among its neighbors. This way, we scan the entire neighborhood of the violating variable until it no longer violates the determined upper bound. This method can be called such a multi-stage heuristic since we don't consider all the possible swaps between the violating variable and its neighbors. Instead, we select the node that has violated the bound and swap it by all other adjacent nodes, and hence it can be considered a linear neighborhood. However, if we had considered all the possible swaps, it would be a quadratic neighborhood O(n^2) where "n" is the adjacent nodes to the violating node and itself.
