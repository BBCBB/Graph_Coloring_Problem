# Graph_Coloring_Problem
This code is under review and improvement to tackle challenging problems in terms of size and diversity.
In order to solve this problem efficiently in terms of the solving time and the quality of the solution (how you can color the graph with the minimum number of colors), you need to know about constraint programming and symmetry breaking approaches. However, there is not a uniform and predefined strategy to do so. First Fail Principle can be helpful in many areas, which states that “To succeed, try first where you are most likely to fail.” In other words, you need to prioritize the nodes that have the most degrees.
I have tried two strategies so far. In the first one, I let the algorithm choose the nodes based on their degrees, and in the second one, I tried the saturation degree of the nodes firstly, and if it was the same for multiple nodes, I chose the node with the largest degree. Surprisingly, the first one performs better than the latter (Coloring_Sat in the repository). In the next step, I will try other approaches like letting in different permutations when the chromatic number of the graph exceeds an upper bound.

Update: I tried another strategy with two phases to deal with the problem. In this strategy, an upper bound to the chromatic number is defined by the user. In the first layer, you should address the problem using the second strategy stated above and choose nodes to assign a color based on their saturation degree. Nevertheless, whenever the assigned color exceeds the defined upper bound, you must backtrack. In other words, in this situation, the algorithm tends to avoid violating the upper bound constraint by trying other schemes and permutations for the neighbor nodes to the node that its color had exceeded the bound. I used this algorithm to solve problems with different sizes and found it useful and efficient in graphs with less than 1000 nodes, 250000 edges, and 550 as the largest degree for a node. In this problem, I let the program 1 hour, but it was not able to come up with a solution. As a result, there is a trade-off between solving time and optimality here, and I recommend choosing new nodes only based on their degree (not saturation degree) in large-scale problems.
